[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "thomas_walker_ICMB_HS24",
    "section": "",
    "text": "This is a Quarto website. I wrote here too\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\nCode1 + 1\n\n[1] 2\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "About",
      "thomas_walker_ICMB_HS24"
    ]
  },
  {
    "objectID": "hw2.1/index.html",
    "href": "hw2.1/index.html",
    "title": "Assignment 2.1",
    "section": "",
    "text": "This is for the second part of the assignment.\nSo I think this phenomena gets explained easily by one sentence:\n“Winners can keep winning while losers cant lose everything.”\nIf you get more of the share for multiple times (since there are a lot of citizens there have to be people as well that “win” multiple times in a sucession. So some people get super lucky (as someone kinda “has” to be in a pool of 5000 people playing this game 10’000 rounds long). Which means a lot of money gets concentrated for those lucky streaks. Once your poor however, you dont have many chances to get rich as most other people get poorer too, so you mostly mingle with them when you are trading.\nMy theory could be tested by putting a limit on the winning amount. Lets test that\nWe are using a trunctuated normal distribution and set the max someone can get from a distribution to the double of the mean (=200). To have a value of 200 or above is already is crazy to achieve, as my code here explains mathematically:\n\nCode# Function to calculate the likelihood of a value being greater than a threshold\nlikelihood_above_threshold &lt;- function(mean, sd, threshold) {\n  # Use pnorm() to calculate the cumulative probability up to the threshold\n  prob_below_threshold &lt;- pnorm(threshold, mean = mean, sd = sd)\n  \n  # Probability above the threshold is 1 minus the cumulative probability\n  prob_above_threshold &lt;- 1 - prob_below_threshold\n  \n  return(prob_above_threshold)\n}\n\n# Example: Calculate the likelihood of wealth above 200 in a population with mean 100 and SD 20\nmean_wealth &lt;- 100\nsd_wealth &lt;- 20\nthreshold &lt;- 200\n\nlikelihood &lt;- likelihood_above_threshold(mean_wealth, sd_wealth, threshold)\nprint(likelihood)\n\n[1] 2.866516e-07\n\n\ninstalling packages truncnorm\n\nCodeN  &lt;- 5000 # Population.\nMU &lt;- 100. # Mean of the Population\nstd_dev &lt;- MU/5 # Standard deviation\nmin_limit &lt;- 0  # Minimum value\nmax_limit &lt;- 200  # Maximum value\nlibrary(truncnorm)\npopulation &lt;- rtruncnorm(N, a = min_limit, b = max_limit, mean = MU, sd = std_dev)\nhist(population, breaks = 50, main = \"Truncated Gaussian Distribution\", \n     xlab = \"Values\", col = \"skyblue\")\n\n\n\n\n\n\n\nNow its the same game as before,creating the simulation.\n\nCoderound_population &lt;- round(population)\n\n\nanyone &lt;- function(round_population){\n  sample(1:length(round_population), 2)\n}\n\nrandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- sample(0:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n  #adding the while loop after means that the parts have to be reshuffled at least once, else the while wouldnt get activated\n while (part1 &gt; 200 || part2 &gt; 200 || (part1 == 0 && part2 == 0)) {\n    part1 &lt;- sample(0:pot, 1)  # Randomly assign part1\n    part2 &lt;- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nsimulation &lt;- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people &lt;- anyone(round_population)\n      #getting the people for trading\n      person1 &lt;- round_population[selected_people[1]]\n      person2 &lt;- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth &lt;- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] &lt;- new_wealth[1]\n      round_population[selected_people[2]] &lt;- new_wealth[2]\n      \n  }\n  return(round_population)\n}\n\nrepetitions &lt;- 10000\n\nfinal_population &lt;- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n\n\n\n\n\n\n\nSo I was right so far.\nLets see if this just needs more repetitions until its back to the old one, as it could just be that case. (It worked but rendering this takes super long Im sorry)\n\nCodesimulation &lt;- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people &lt;- anyone(round_population)\n      #getting the people for trading\n      person1 &lt;- round_population[selected_people[1]]\n      person2 &lt;- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth &lt;- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] &lt;- new_wealth[1]\n      round_population[selected_people[2]] &lt;- new_wealth[2]\n      \n  }\n  return(round_population)\n}\n\nrepetitions &lt;- 100000 #added one more zero\n\nfinal_population &lt;- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n\n\nStill looks the same. So I was (probably) right. Maybe this also hints at some form of limitarianism we should implement in our political and societal system, like the (living!) philosopher and idol Ingrid Robeyns advocates for…\nAnd if we even take into account how unlikely it is to even be in the top 200 based on luck, there would even be a case to lower that limit.\n\nSo I think that the way numbers work, small stays small and big stays big. The distribution also looks deceptively like one half of a gaussian distribution. So how about we test that too. We let the numbers go into the negative as well while keeping our premises of splitting the money.\nSo when two actors meet, they still can’t produce more money, but they can split it in a way, where someone gets left with debts, as long as both numbers add up to each other. However, we cant let total freedom reign this, as then abnormally high numbers could be produced (-1100 and 1300 still gives the initial 200 that used to be in the pot.) Additionally, we cant just propose an absolute value as then then the poor people could just come out of poverty by trading in a way that someone gets super rich and the other super poor, which also in the model before couldn’t be done. So we have to come up with a relative value where we avoid blatant fails like that. To better illustrate my idea that Im trying to convey we can imagine how a bank would go about this: a reasonable bank would not give a very rich and a very poor person the same amount of loans. The loans are relative to the income and wealth that people have.\nSo how do we come up with a relative, reasonable number? If we look at the graph, we can see that the cap of the richest people is around 800 (?) but the last few that are continous to each other caps at around 500. This means that the first necessary step to get to be super rich is around 250-400 (as these numbers times 2 means you get to be la creme de la creme). in mathematical terms Id describe the range of the negative to the positive values like this then:\n- Max possible value with one trade: P1+P2+(P1+P2)/2\n- Min possible value with one trade: -(P1+P2)/2\nAnd in the end, there also has to be a maximum egative value for my limiting programming skills to match it, which is going to be -999. You can NEVER have less than -999 money.\n\nCodeN  &lt;- 5000 # Population.\nMU &lt;- 100. # Mean of the Population\nstd_dev &lt;- MU/5 # Standard deviation\n\npopulation &lt;- rnorm(N, mean = MU, sd = std_dev)\nround_population &lt;- round(population)\n\n\nanyone &lt;- function(round_population){\n  population &lt;- population + 1000\n  sample(0:2000, 2) \n  population &lt;- population - 1000\n}\n\nrandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y+1000\n  #how to share\n  part1 &lt;- sample(0:pot, 1)\n  part1 &lt;- part1-1000\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n\n  pcf &lt;- -(part1+part2)/2\n\n while (part1 &lt; -1000 || part2 &lt; -1000 || (part1 == 0 && part2 == 0)) {\n    part1 &lt;- sample(0:pot, 1)# Randomly assign part1\n    part1 &lt;- part1-1000\n    part2 &lt;- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n  \n  while (part1 &lt; -1000 || part2 &lt; -1000 || (part1 == 0 && part2 == 0)) {\n    part1 &lt;- sample(0:pot, 1)# Randomly assign part1\n    part1 &lt;- part1-1000\n    part2 &lt;- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nsimulation &lt;- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people &lt;- anyone(round_population)\n      #getting the people for trading\n      person1 &lt;- round_population[selected_people[1]]\n      person2 &lt;- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth &lt;- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] &lt;- new_wealth[1]\n      round_population[selected_people[2]] &lt;- new_wealth[2]\n      \n  }\n  return(round_population)\n}\n\nrepetitions &lt;- 1000\n\nfinal_population &lt;- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n\n\n\n\n\n\n\nTesting smaller versions to see where the mistake is\n\nCoderandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- sample(-1000:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n\n  pcf &lt;- -(part1+part2)/2\n\n while (part1 &lt; pcf || part2 &lt; pcf || (part1 == 0 && part2 == 0)) {\n    part1 &lt;- sample(-1000:pot, 1)  # Randomly assign part1\n    part2 &lt;- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nrandom_split(100,100)\n\n[1]  -4 204\n\n\nI meddled a lot, Ill try again.\nNew try\n\nCodeanyone &lt;- function(round_population){\n  sample(round_population,2)\n  #runif(1, min = -1000, max = 1000) \n}\n\nrandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- sample(-1000:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n\n  pcf &lt;- -(part1+part2)/2\n\n while (part1 &lt; pcf || part2 &lt; pcf || (part1 == 0 && part2 == 0)) {\n    part1 &lt;- sample(-1000:pot, 1)  # Randomly assign part1\n    part2 &lt;- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nrandom_split(100,100)\n\n[1] -65 265\n\nCodeselected_people &lt;- anyone(round_population)      \n#getting the people for trading\nperson1 &lt;- round_population[selected_people[1]]\nperson2 &lt;- round_population[selected_people[2]]\n#making the new wealth distribution between those two\nnew_wealth &lt;- random_split(person1, person2)\n#overwriting the old bank statement with the new one\nround_population[selected_people[1]] &lt;- new_wealth[1]\nround_population[selected_people[2]] &lt;- new_wealth[2]\n\n\nBig try:\n\nCodeanyone &lt;- function(round_population){\n  sample(round_population,2)\n}\n\nrandom_split &lt;- function(x,y) {\n  # Sum them up\n  x_was_negative &lt;- FALSE\n  if (x&lt;0){\n    x&lt;-2*x\n    x_was_negative &lt;- TRUE\n  } \n  if (y&lt;0){\n    y &lt;- y*2\n  }\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- sample(-1000:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n\n  pcf &lt;- -(part1+part2)/2\n\n while (part1 &lt; pcf || part2 &lt; pcf || (part1 == 0 && part2 == 0)) {\n    part1 &lt;- sample(-1000:pot, 1)  # Randomly assign part1\n    part2 &lt;- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nrandom_split(100,100)\n\nsimulation &lt;- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people &lt;- anyone(round_population)\n      #getting the people for trading\n      person1 &lt;- round_population[selected_people[1]]\n      person2 &lt;- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth &lt;- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] &lt;- new_wealth[1]\n      round_population[selected_people[2]] &lt;- new_wealth[2]\n  }\n  return(round_population)\n}\n\nrepetitions &lt;- 10\n\nfinal_population &lt;- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n\n\n\nCoderandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- sample(-pot:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n  \n  pcf &lt;- -abs(part1+part2)/2\n\n while (part1 &lt; pcf || part2 &lt; pcf || (part1 == 0 && part2 == 0)) {\n    part1 &lt;- sample(-pot:pot, 1)  # Randomly assign part1\n    part2 &lt;- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\nrandom_split(100,100)\n\n[1]  71 129\n\n\nI think I solved it now, there were many problems with numbers that were either the same, or when it was their negative part when adding them together. I first tried to add them to the pot but if it happens that x=100 and y = -100 then the pot is zero. So then I put the absolute value in, which would be 200 again. Then it could happen that if both have 100 then the difference is 0, making them lose 200 bucks.\n(spoiler: I didnt solve it, trying it again with the code above) The code was doing it that if I put 100 and -80 the sum is 180 so the model split than one randomly, generating money in that process.\nNow the problem is if both numbers cancel each other out, like 80 and -80. Here I just decided that if that is the case they just dont do anything.\nNow Im also searching for indices, cuz chatgpt told me too (so I can avoid duplicates)\n(I removed the zeros from the normal distribution to random 1s and -1s as its super inconveniant to calculate my stuffs with zeros) maybe a project for another time.\n\nCodeN  &lt;- 5000 # Population.\nMU &lt;- 0 # Mean of the Population\nstd_dev &lt;- 20 # Standard deviation\n\npopulation &lt;- rnorm(N, mean = MU, sd = std_dev)\npopulation[population == 0] &lt;- sample(c(-1, 1), length(population[population == 0]), replace = TRUE)\nround_population &lt;- round(population)\n\nanyone &lt;- function(round_population){\n  sample(seq_along(round_population), 2)\n}\n\nrandom_split &lt;- function(x,y){\n  # Sum them up\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- sample(-pot:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n  \n  too_small &lt;- -abs(part1 + part2) / 2\n  too_big &lt;- part1 + part2 + (part1+part2) / 2\n  too_big\n\n while (part1 &lt; too_small || part2 &lt; too_small || \n       (part1 == 0 && part2 == 0) || \n       (part1 &gt; too_big) || (part2 &gt; too_big)) {\n  part1 &lt;- sample(-pot:pot, 1)  # Randomly assign part1\n  part2 &lt;- pot - part1 \n  }\n  return(c(part1, part2))\n}\n\n\nsimulation &lt;- function(round_population,repetitions) \n  {\n  for (i in 1:repetitions) {\n      selected_people &lt;- anyone(round_population)\n      #getting the people for trading\n      person1 &lt;- round_population[selected_people[1]]\n      person2 &lt;- round_population[selected_people[2]]\n      while(person1 == person2){\n        selected_people &lt;- anyone(round_population)\n        #getting the people for trading\n        person1 &lt;- round_population[selected_people[1]]\n        person2 &lt;- round_population[selected_people[2]]\n      }\n      #making the new wealth distribution between those two\n      new_wealth &lt;- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] &lt;- new_wealth[1]\n      round_population[selected_people[2]] &lt;- new_wealth[2]\n  }\n  return(round_population)\n}\n\nrepetitions &lt;- 10\n\nfinal_population &lt;- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n\n\nffndsafjaewklnfdsad I DID IT HELL YES IM SO HAPPY WHAT THE HELL I HAVE BEEN UPDATING THIS CODE NOW PROBS FOR 5 HOURS ONLY AND I GO TIT KFDNHSALFJDJKLÖADSLKNDFSNAKLNKLIHO\nDanke Paul dass mer ned uf de Autobahn verunfallt sind (er isch eus heigfahre). Danke Amy fürd unterhaltig vom paul (dass er ned ihschlaft) & das er überlebt (amy het ihm wasser geh). Larissa het gueti Musig gmacht. Und danke Thomas dass er eh paar stunde ned nervig gsi isch.\ndown here is my notepad\n\nCoderandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- sample(-pot:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n  \n  too_small &lt;- -abs(part1+part2)/2\n  too_big &lt;- part1+part2+(part1+part2)/2\n  too_big}\nrandom_split(100,100)\n\n[1] 300\n\n\n\nCodeN  &lt;- 5000 # Population.\nMU &lt;- 0 # Mean of the Population\nstd_dev &lt;- 20 # Standard deviation\n\npopulation &lt;- rnorm(N, mean = MU, sd = std_dev)\npopulation[population == 0] &lt;- sample(c(-1, 1), length(population[population == 0]), replace = TRUE)\nround_population &lt;- round(population)\n\nanyone &lt;- function(round_population){\n  sample(seq_along(round_population), 2)\n}\n\nrandom_split &lt;- function(x, y) {\n  pot &lt;- x + y\n  # Ensuring no 0s and reasonable splits\n  part1 &lt;- sample(max(-pot + 1, -100):min(pot - 1, 100), 1)\n  part2 &lt;- pot - part1\n  too_small &lt;- -abs(part1 + part2) / 2\n  too_big &lt;- part1 + part2 + (part1 + part2) / 2\n  \n  while (part1 &lt; too_small || part2 &lt; too_small || (part1 &gt; too_big) || (part2 &gt; too_big)) {\n    part1 &lt;- sample(max(-pot + 1, -100):min(pot - 1, 100), 1)  # Avoiding zero\n    part2 &lt;- pot - part1\n  }\n  \n  return(c(part1, part2))\n}\n\nsimulation &lt;- function(round_population, repetitions) {\n  for (i in 1:repetitions) {\n    selected_people &lt;- anyone(round_population)\n    person1 &lt;- round_population[selected_people[1]]\n    person2 &lt;- round_population[selected_people[2]]\n    \n    # Ensure two different people\n    while (selected_people[1] == selected_people[2]) {\n      selected_people &lt;- anyone(round_population)\n      person1 &lt;- round_population[selected_people[1]]\n      person2 &lt;- round_population[selected_people[2]]\n    }\n    \n    new_wealth &lt;- random_split(person1, person2)\n    \n    # Update the population\n    round_population[selected_people[1]] &lt;- new_wealth[1]\n    round_population[selected_people[2]] &lt;- new_wealth[2]\n  }\n  return(round_population)\n}\n\nrepetitions &lt;- 10\nfinal_population &lt;- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n\n\n\nCodeN  &lt;- 5000 # Population.\nMU &lt;- 0 # Mean of the Population\nstd_dev &lt;- 20 # Standard deviation\n\npopulation &lt;- rnorm(N, mean = MU, sd = std_dev)\npopulation[population == 0] &lt;- sample(c(-1, 1), length(population[population == 0]), replace = TRUE)\nround_population &lt;- round(population)\n\nanyone &lt;- function(round_population){\n  sample(seq_along(round_population), 2)\n}\nanyone(round_population)\n\n[1]  671 3704\n\nCoderandom_split &lt;- function(x,y){\n  # Sum them up\n  pot &lt;- x+y\n  if(pot == 0){\n    pot &lt;- x\n  }\n  #how to share\n  part1 &lt;- sample(-pot:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n  \n  too_small &lt;- -abs(part1 + part2) / 2\n  too_big &lt;- part1 + part2 + (part1+part2) / 2\n  too_big\n\n while (part1 &lt; too_small || part2 &lt; too_small || \n       (part1 == 0 && part2 == 0) || \n       (part1 &gt; too_big) || (part2 &gt; too_big)) {\n  part1 &lt;- sample(-pot:pot, 1)  # Randomly assign part1\n  part2 &lt;- pot - part1 \n  }\n  return(c(part1, part2))\n}\n\nrandom_split(50,-50)\n\n[1] 26 24\n\nCodesimulation &lt;- function(x,y) \n  {\n  for (i in 1:y) {\n      selected_people &lt;- anyone(x)\n      #getting the people for trading\n      person1 &lt;- round_population[selected_people[1]]\n      person2 &lt;- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth &lt;- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] &lt;- new_wealth[1]\n      round_population[selected_people[2]] &lt;- new_wealth[2]\n  }\n  return(round_population)\n}\n\nrepetitions &lt;- 10\n\n#final_population &lt;- simulation(round_population, repetitions)\n\n#final_population\n\nhist(round_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n\n\n\n\n\n\n\nI got a new idea, for this I need a new page\n\n\n\n\n\n Back to top",
    "crumbs": [
      "About",
      "Assignment 2.1"
    ]
  },
  {
    "objectID": "hw1/index.html",
    "href": "hw1/index.html",
    "title": "Assignment 1.0",
    "section": "",
    "text": "Why is the title here My assignment I dont see it here on the doc\nUpdate please\n\nCodex &lt;- rnorm(10000, mean = 100, sd = 15)\nhist(x)\n\n\n\n\n\n\n\nThis is the new text\n\n\n\n\n\n Back to top",
    "crumbs": [
      "About",
      "Assignment 1.0"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\nCode1 + 1\n\n[1] 2\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "hw2/index.html",
    "href": "hw2/index.html",
    "title": "Assignment 2.0",
    "section": "",
    "text": "This is my try to replicate the simulation according to the assignment of replicating this simulation found here.\nSince the import random code didnt work out, Ill rewrite the code with the rnorm code, that should give us the same curve. Also creating a histogram for us to see.\n\nCodeN  &lt;- 5000 # Population\nMU &lt;- 100. # Mean of the Population\nstd_dev &lt;- 15 # Standard deviation\n\npopulation &lt;- rnorm(N, mean = MU, sd = std_dev)\n\nhist(population, breaks = 50, main = \"Random Gaussian Distribution\", xlab = \"Value\", col = \"skyblue\")\n\n\n\n\n\n\n\nNow we are computing the gini coefficient. (chatgpt assisted)\n\nCodegini &lt;- function(y) {\n  # Sort the population\n  y &lt;- sort(y)\n  \n  # Number of elements\n  n &lt;- length(y)\n  \n  # Calculate the Gini coefficient\n  numer &lt;- 2 * sum((1:n) * y)\n  denom &lt;- n * sum(y)\n  \n  # Return the Gini coefficient\n  return((numer / denom) - (n + 1) / n)\n}\n\n\nNow, lets put my population into the gini coefficient.\n\nCodegini(population)\n\n[1] 0.0847681\n\n\nHere is me running my simulation multiple times to see if this was a fluke:\n\nCodepopulation1 &lt;- rnorm(N, mean = MU, sd = std_dev)\npopulation2 &lt;- rnorm(N, mean = MU, sd = std_dev)\npopulation3 &lt;- rnorm(N, mean = MU, sd = std_dev)\npopulation4 &lt;- rnorm(N, mean = MU, sd = std_dev)\npopulation5 &lt;- rnorm(N, mean = MU, sd = std_dev)\n\ngini(population1)\n\n[1] 0.08331847\n\nCodegini(population2)\n\n[1] 0.08309262\n\nCodegini(population3)\n\n[1] 0.08386314\n\nCodegini(population4)\n\n[1] 0.08499821\n\nCodegini(population5)\n\n[1] 0.08513986\n\n\nWe see that its always around 0.084. Which is a bit weird since in the simulation of the document Im reading puts the gini coeff at 0.11. Since the error is pretty consistent, I suspect an error in my code. I read through the parameters of the gaussian distribution and saw that the put a small formula into the std_dev part: MU/5. Which is std_dev = 20 but I used std_dev = 15.\nLets change that and see whats up\n\nCodeN  &lt;- 5000 # Population\nMU &lt;- 100. # Mean of the Population\nstd_dev2 &lt;- MU/5 # Standard deviation\n\npopulation &lt;- rnorm(N, mean = MU, sd = std_dev2)\n\nhist(population, breaks = 50, main = \"Random Gaussian Distribution\", xlab = \"Value\", col = \"skyblue\")\n\n\n\n\n\n\n\nThe histogram already looks a bit flatter, which should imply a higher gini coefficient as its more unequal.\n\nCodegini(population)\n\n[1] 0.1117662\n\n\nPerfect. Now lets test again if its a fluke.\n\nCodepopulation1 &lt;- rnorm(N, mean = MU, sd = std_dev2)\npopulation2 &lt;- rnorm(N, mean = MU, sd = std_dev2)\npopulation3 &lt;- rnorm(N, mean = MU, sd = std_dev2)\npopulation4 &lt;- rnorm(N, mean = MU, sd = std_dev2)\npopulation5 &lt;- rnorm(N, mean = MU, sd = std_dev2)\n\ngini(population1)\n\n[1] 0.1118576\n\nCodegini(population2)\n\n[1] 0.1132838\n\nCodegini(population3)\n\n[1] 0.1122562\n\nCodegini(population4)\n\n[1] 0.1120957\n\nCodegini(population5)\n\n[1] 0.1121591\n\n\nNow in the end, Ill do the histogram prettier.\n\nCodehist(population, breaks = 50, main = \"Random Gaussian Distribution\", xlab = \"wealth\", ylab = \"count\", col = \"skyblue\")\ngini_text &lt;- round(gini(population),4)\ntext(x = 150, y = 400, labels = paste(gini_text), col = \"skyblue\", cex = 1.5)\n\n\n\n\n\n\n\nThis suffices.\nNow Ill write the function of the money splitting. To be honest, I have never written a function myself but I can use the gini function as a blueprint.\n\nCoderandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- runif(1, min=0, max=pot)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n  # Return the Gini coefficient\n  return(c(part1, part2))\n}\n\n\nLets run this bad boy\n\nCoderandom_split(30,70)\n\n[1] 67.14333 32.85667\n\n\nOkay so I dont like how it splits the money into so many small parts. This doesnt make sense as we in real life dont do that either. If we want bigger numbers, Ill just up the amount of money people trade with. Else why did we put the number on 100 if we are taking in numbers in the millions??? Exactly.\n\nCoderandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y\n  \n  #how to share\n  part1 &lt;- sample(0:pot, 1)\n  \n  #calcutlating the  split \n  part2 &lt;- pot - part1\n  \n  # Return the Gini coefficient\n  return(c(part1, part2))\n}\nrandom_split(70,30)\n\n[1] 15 85\n\n\nbetter.\nNow, like in the guide, lets see if we can pick two random citiziens of our population.\n\nCodeanyone &lt;- function(x){\n  sample(0:N, 2)\n}\n\nanyone(N) \n\n[1]  661 3002\n\n\nNow lets officially start with simulating whueee :)))\n\nCode\"simulate &lt;- function(N, repetitions){\n  history &lt;- list()\n  #so that the first entry is the population we started with\n  history[[1]] &lt;- N\n  \n  for (t in 1:repetitions){\n    selected_people &lt;- anyone(N)\n    #getting the people for trading\n    person1 &lt;- selected_people[1]\n    person2 &lt;- selected_people[2]\n    #getting them the amount what they traded\n    new_wealth &lt;- random_split(person1, person2)\n    #Updating their money\n    N[N == person1] &lt;- new_wealth[1]\n    N[N == person2] &lt;- new_wealth[2]\n    #Record the current state of the population\n    history[[t+1]] &lt;- population\n  }\n  \n  return(history)\n}\n\nrepetitions &lt;-1\n\nsimulate(population, repetitions)\"\n\n[1] \"simulate &lt;- function(N, repetitions){\\n  history &lt;- list()\\n  #so that the first entry is the population we started with\\n  history[[1]] &lt;- N\\n  \\n  for (t in 1:repetitions){\\n    selected_people &lt;- anyone(N)\\n    #getting the people for trading\\n    person1 &lt;- selected_people[1]\\n    person2 &lt;- selected_people[2]\\n    #getting them the amount what they traded\\n    new_wealth &lt;- random_split(person1, person2)\\n    #Updating their money\\n    N[N == person1] &lt;- new_wealth[1]\\n    N[N == person2] &lt;- new_wealth[2]\\n    #Record the current state of the population\\n    history[[t+1]] &lt;- population\\n  }\\n  \\n  return(history)\\n}\\n\\nrepetitions &lt;-1\\n\\nsimulate(population, repetitions)\"\n\n\nThis next code block is to test some small parts of the code above and see where the problem is.\n\nCodeselected_people &lt;- anyone(round_population)\n    #getting the people for trading\n    person1 &lt;- selected_people[1]\n    person2 &lt;- selected_people[2]\n    \nperson1\n\n[1] 3337\n\nCodeperson2\n\n[1] 307\n\nCoderandom_split(person1, person2)\n\n[1] 1790 1854\n\n\nI have run into several problems and started solving them in the editor. I think its better if I describe some procesess I have been doing though. So I still get decimals in the gaussian distribution, which I dont want. So Ill change that.\n\nCoderound_population &lt;- round(population)\n\nhist(round_population, breaks = 50, main = \"Random Gaussian Distribution\", xlab = \"Value\", col = \"skyblue\")\n\n\n\n\n\n\n\nAgain, some shenanigangs.\n\nCodeperson1\n\n[1] 3337\n\nCodeperson2\n\n[1] 307\n\n\n\nCodeselected_people &lt;- anyone(round_population)\n#getting the people for trading\nperson1 &lt;- selected_people[1]\nperson2 &lt;- selected_people[2]\nperson1\n\n[1] 3529\n\nCodeperson2\n\n[1] 598\n\nCode    #getting them the amount what they traded\nnew_wealth &lt;- random_split(person1, person2)\n    #Updating their money\nround_population[round_population == person1] &lt;- new_wealth[1]\nround_population[round_population == person2] &lt;- new_wealth[2]\nperson1\n\n[1] 3529\n\nCodeperson2\n\n[1] 598\n\nCode    #Record the current state of the population\n    #history[[t+1]] &lt;- round_population\n  #}\n  \n\n\n#simulate(round_population, repetitions)\n\n\nall in one thing:\n\nCodeN  &lt;- 5000 # Population.\nMU &lt;- 100 # Mean of the Population\nstd_dev &lt;- MU/5 # Standard deviation\n\npopulation &lt;- rnorm(N, mean = MU, sd = std_dev)\nround_population &lt;- round(population)\n\n\nanyone &lt;- function(round_population){\n  sample(1:length(round_population), 2)\n}\n\nrandom_split &lt;- function(x,y) {\n  # Sum them up\n  pot &lt;- x+y\n  #how to share\n  part1 &lt;- sample(0:pot, 1)\n  #calcutlating the  split \n  part2 &lt;- pot - part1\n  # Return the Gini coefficient\n  return(c(part1, part2))\n}\n\nsimulation &lt;- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people &lt;- anyone(round_population)\n      #getting the people for trading\n      person1 &lt;- round_population[selected_people[1]]\n      person2 &lt;- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth &lt;- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] &lt;- new_wealth[1]\n      round_population[selected_people[2]] &lt;- new_wealth[2]\n      \n  }\n  return(round_population)\n}\n\nrepetitions &lt;- 10000\n\nfinal_population &lt;- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n\n\n\n\n\n\n\nThis IS CORRECT I WANT TO SCREAM OH MY GOD I CHANGED SO MUCH AND NOW I GET IT YAAAs.\nI also noticed that only starting at like 10’000 simulations we get this distribution, before that we dont. (Maybe Ill implement this in this website we will see)\n\n\n\n\n\n Back to top",
    "crumbs": [
      "About",
      "Assignment 2.0"
    ]
  },
  {
    "objectID": "hw2.2/index.html",
    "href": "hw2.2/index.html",
    "title": "Minus and Plus Curve",
    "section": "",
    "text": "So I made everything overcomplicated whereas I think I should keep the rules of the economy simple: both numbers get added with their absolute difference to 0 (|x|). So maximum = pot and minimum =-pot for the first value we get. After randomly assigning the first value we get (z) from that rane . We proceed by summing up x and y. This will give us their absolute value of worth. This one minus z should give us the new q.\n\nCodeN  &lt;- 5000 # Population.\nMU &lt;- 0 # Mean of the Population\nstd_dev &lt;- 20 # Standard deviation\n\npopulation &lt;- rnorm(N, mean = MU, sd = std_dev)\nround_population &lt;- round(population)\n\nanyone &lt;- function(round_population){\n  sample(seq_along(round_population), 2)\n}\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "About",
      "Minus and Plus Curve"
    ]
  }
]