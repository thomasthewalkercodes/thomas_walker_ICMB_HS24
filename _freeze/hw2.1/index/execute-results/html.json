{
  "hash": "e0c7f24095576fdc3cfd652bfe12079d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 2.1\"\nauthor: \"Thomas Walker\"\n---\n\n\nThis is for the second part of the assignment.\n\nSo I think this phenomena gets explained easily by one sentence:\n\n\"Winners can keep winning while losers cant lose everything.\"\n\nIf you get more of the share for multiple times (since there are a lot of citizens there have to be people as well that \"win\" multiple times in a sucession. So some people get super lucky (as someone kinda \"has\" to be in a pool of 5000 people playing this game 10'000 rounds long). Which means a lot of money gets concentrated for those lucky streaks. Once your poor however, you dont have many chances to get rich as most other people get poorer too, so you mostly mingle with them when you are trading.\n\nMy theory could be tested by putting a limit on the winning amount. Lets test that\n\nWe are using a trunctuated normal distribution and set the max someone can get from a distribution to the double of the mean (=200). To have a value of 200 or above is already is crazy to achieve, as my code here explains mathematically:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to calculate the likelihood of a value being greater than a threshold\nlikelihood_above_threshold <- function(mean, sd, threshold) {\n  # Use pnorm() to calculate the cumulative probability up to the threshold\n  prob_below_threshold <- pnorm(threshold, mean = mean, sd = sd)\n  \n  # Probability above the threshold is 1 minus the cumulative probability\n  prob_above_threshold <- 1 - prob_below_threshold\n  \n  return(prob_above_threshold)\n}\n\n# Example: Calculate the likelihood of wealth above 200 in a population with mean 100 and SD 20\nmean_wealth <- 100\nsd_wealth <- 20\nthreshold <- 200\n\nlikelihood <- likelihood_above_threshold(mean_wealth, sd_wealth, threshold)\nprint(likelihood)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.866516e-07\n```\n\n\n:::\n:::\n\n\ninstalling packages truncnorm\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Population.\nMU <- 100. # Mean of the Population\nstd_dev <- MU/5 # Standard deviation\nmin_limit <- 0  # Minimum value\nmax_limit <- 200  # Maximum value\nlibrary(truncnorm)\npopulation <- rtruncnorm(N, a = min_limit, b = max_limit, mean = MU, sd = std_dev)\nhist(population, breaks = 50, main = \"Truncated Gaussian Distribution\", \n     xlab = \"Values\", col = \"skyblue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nNow its the same game as before,creating the simulation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround_population <- round(population)\n\n\nanyone <- function(round_population){\n  sample(1:length(round_population), 2)\n}\n\nrandom_split <- function(x,y) {\n  # Sum them up\n  pot <- x+y\n  #how to share\n  part1 <- sample(0:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n  #adding the while loop after means that the parts have to be reshuffled at least once, else the while wouldnt get activated\n while (part1 > 200 || part2 > 200 || (part1 == 0 && part2 == 0)) {\n    part1 <- sample(0:pot, 1)  # Randomly assign part1\n    part2 <- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nsimulation <- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people <- anyone(round_population)\n      #getting the people for trading\n      person1 <- round_population[selected_people[1]]\n      person2 <- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth <- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] <- new_wealth[1]\n      round_population[selected_people[2]] <- new_wealth[2]\n      \n  }\n  return(round_population)\n}\n\nrepetitions <- 10000\n\nfinal_population <- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nSo I was right so far.\n\nLets see if this just needs more repetitions until its back to the old one, as it could just be that case. (It worked but rendering this takes super long Im sorry)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulation <- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people <- anyone(round_population)\n      #getting the people for trading\n      person1 <- round_population[selected_people[1]]\n      person2 <- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth <- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] <- new_wealth[1]\n      round_population[selected_people[2]] <- new_wealth[2]\n      \n  }\n  return(round_population)\n}\n\nrepetitions <- 100000 #added one more zero\n\nfinal_population <- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n```\n:::\n\n\nStill looks the same. So I was (probably) right. Maybe this also hints at some form of limitarianism we should implement in our political and societal system, like the (living!) philosopher and idol Ingrid Robeyns advocates for...\n\nAnd if we even take into account how unlikely it is to even be in the top 200 based on luck, there would even be a case to lower that limit.\n\n------------------------------------------------------------------------\n\nSo I think that the way numbers work, small stays small and big stays big. The distribution also looks deceptively like one half of a gaussian distribution. So how about we test that too. We let the numbers go into the negative as well while keeping our premises of splitting the money.\n\nSo when two actors meet, they still can't produce more money, but they can split it in a way, where someone gets left with debts, as long as both numbers add up to each other. However, we cant let total freedom reign this, as then abnormally high numbers could be produced (-1100 and 1300 still gives the initial 200 that used to be in the pot.) Additionally, we cant just propose an absolute value as then then the poor people could just come out of poverty by trading in a way that someone gets super rich and the other super poor, which also in the model before couldn't be done. So we have to come up with a relative value where we avoid blatant fails like that. To better illustrate my idea that Im trying to convey we can imagine how a bank would go about this: a reasonable bank would not give a very rich and a very poor person the same amount of loans. The loans are relative to the income and wealth that people have.\n\nSo how do we come up with a relative, reasonable number? If we look at the graph, we can see that the cap of the richest people is around 800 (?) but the last few that are continous to each other caps at around 500. This means that the first necessary step to get to be super rich is around 250-400 (as these numbers times 2 means you get to be la creme de la creme). in mathematical terms Id describe the range of the negative to the positive values like this then:\n\n\\- Max possible value with one trade: P1+P2+(P1+P2)/2\n\n\\- Min possible value with one trade: -(P1+P2)/2\n\nAnd in the end, there also has to be a maximum egative value for my limiting programming skills to match it, which is going to be -999. You can NEVER have less than -999 money.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Population.\nMU <- 100. # Mean of the Population\nstd_dev <- MU/5 # Standard deviation\n\npopulation <- rnorm(N, mean = MU, sd = std_dev)\nround_population <- round(population)\n\n\nanyone <- function(round_population){\n  population <- population + 1000\n  sample(0:2000, 2) \n  population <- population - 1000\n}\n\nrandom_split <- function(x,y) {\n  # Sum them up\n  pot <- x+y+1000\n  #how to share\n  part1 <- sample(0:pot, 1)\n  part1 <- part1-1000\n  #calcutlating the  split \n  part2 <- pot - part1\n\n  pcf <- -(part1+part2)/2\n\n while (part1 < -1000 || part2 < -1000 || (part1 == 0 && part2 == 0)) {\n    part1 <- sample(0:pot, 1)# Randomly assign part1\n    part1 <- part1-1000\n    part2 <- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n  \n  while (part1 < -1000 || part2 < -1000 || (part1 == 0 && part2 == 0)) {\n    part1 <- sample(0:pot, 1)# Randomly assign part1\n    part1 <- part1-1000\n    part2 <- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nsimulation <- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people <- anyone(round_population)\n      #getting the people for trading\n      person1 <- round_population[selected_people[1]]\n      person2 <- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth <- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] <- new_wealth[1]\n      round_population[selected_people[2]] <- new_wealth[2]\n      \n  }\n  return(round_population)\n}\n\nrepetitions <- 1000\n\nfinal_population <- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nTesting smaller versions to see where the mistake is\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(x,y) {\n  # Sum them up\n  pot <- x+y\n  #how to share\n  part1 <- sample(-1000:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n\n  pcf <- -(part1+part2)/2\n\n while (part1 < pcf || part2 < pcf || (part1 == 0 && part2 == 0)) {\n    part1 <- sample(-1000:pot, 1)  # Randomly assign part1\n    part2 <- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nrandom_split(100,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  -4 204\n```\n\n\n:::\n:::\n\n\nI meddled a lot, Ill try again.\n\nNew try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyone <- function(round_population){\n  sample(round_population,2)\n  #runif(1, min = -1000, max = 1000) \n}\n\nrandom_split <- function(x,y) {\n  # Sum them up\n  pot <- x+y\n  #how to share\n  part1 <- sample(-1000:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n\n  pcf <- -(part1+part2)/2\n\n while (part1 < pcf || part2 < pcf || (part1 == 0 && part2 == 0)) {\n    part1 <- sample(-1000:pot, 1)  # Randomly assign part1\n    part2 <- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nrandom_split(100,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -65 265\n```\n\n\n:::\n\n```{.r .cell-code}\nselected_people <- anyone(round_population)      \n#getting the people for trading\nperson1 <- round_population[selected_people[1]]\nperson2 <- round_population[selected_people[2]]\n#making the new wealth distribution between those two\nnew_wealth <- random_split(person1, person2)\n#overwriting the old bank statement with the new one\nround_population[selected_people[1]] <- new_wealth[1]\nround_population[selected_people[2]] <- new_wealth[2]\n```\n:::\n\n\nBig try:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyone <- function(round_population){\n  sample(round_population,2)\n}\n\nrandom_split <- function(x,y) {\n  # Sum them up\n  x_was_negative <- FALSE\n  if (x<0){\n    x<-2*x\n    x_was_negative <- TRUE\n  } \n  if (y<0){\n    y <- y*2\n  }\n  pot <- x+y\n  #how to share\n  part1 <- sample(-1000:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n\n  pcf <- -(part1+part2)/2\n\n while (part1 < pcf || part2 < pcf || (part1 == 0 && part2 == 0)) {\n    part1 <- sample(-1000:pot, 1)  # Randomly assign part1\n    part2 <- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\n\nrandom_split(100,100)\n\nsimulation <- function(round_population,repetitions) {\n  for (i in 1:repetitions) {\n      selected_people <- anyone(round_population)\n      #getting the people for trading\n      person1 <- round_population[selected_people[1]]\n      person2 <- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth <- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] <- new_wealth[1]\n      round_population[selected_people[2]] <- new_wealth[2]\n  }\n  return(round_population)\n}\n\nrepetitions <- 10\n\nfinal_population <- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(x,y) {\n  # Sum them up\n  pot <- x+y\n  #how to share\n  part1 <- sample(-pot:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n  \n  pcf <- -abs(part1+part2)/2\n\n while (part1 < pcf || part2 < pcf || (part1 == 0 && part2 == 0)) {\n    part1 <- sample(-pot:pot, 1)  # Randomly assign part1\n    part2 <- pot - part1  # The remainder goes to part2\n  }\n  return(c(part1, part2))\n}\nrandom_split(100,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  71 129\n```\n\n\n:::\n:::\n\n\nI think I solved it now, there were many problems with numbers that were either the same, or when it was their negative part when adding them together. I first tried to add them to the pot but if it happens that x=100 and y = -100 then the pot is zero. So then I put the absolute value in, which would be 200 again. Then it could happen that if both have 100 then the difference is 0, making them lose 200 bucks.\n\n(spoiler: I didnt solve it, trying it again with the code above) The code was doing it that if I put 100 and -80 the sum is 180 so the model split than one randomly, generating money in that process.\n\nNow the problem is if both numbers cancel each other out, like 80 and -80. Here I just decided that if that is the case they just dont do anything.\n\nNow Im also searching for indices, cuz chatgpt told me too (so I can avoid duplicates)\n\n(I removed the zeros from the normal distribution to random 1s and -1s as its super inconveniant to calculate my stuffs with zeros) maybe a project for another time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Population.\nMU <- 0 # Mean of the Population\nstd_dev <- 20 # Standard deviation\n\npopulation <- rnorm(N, mean = MU, sd = std_dev)\npopulation[population == 0] <- sample(c(-1, 1), length(population[population == 0]), replace = TRUE)\nround_population <- round(population)\n\nanyone <- function(round_population){\n  sample(seq_along(round_population), 2)\n}\n\nrandom_split <- function(x,y){\n  # Sum them up\n  pot <- x+y\n  #how to share\n  part1 <- sample(-pot:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n  \n  too_small <- -abs(part1 + part2) / 2\n  too_big <- part1 + part2 + (part1+part2) / 2\n  too_big\n\n while (part1 < too_small || part2 < too_small || \n       (part1 == 0 && part2 == 0) || \n       (part1 > too_big) || (part2 > too_big)) {\n  part1 <- sample(-pot:pot, 1)  # Randomly assign part1\n  part2 <- pot - part1 \n  }\n  return(c(part1, part2))\n}\n\n\nsimulation <- function(round_population,repetitions) \n  {\n  for (i in 1:repetitions) {\n      selected_people <- anyone(round_population)\n      #getting the people for trading\n      person1 <- round_population[selected_people[1]]\n      person2 <- round_population[selected_people[2]]\n      while(person1 == person2){\n        selected_people <- anyone(round_population)\n        #getting the people for trading\n        person1 <- round_population[selected_people[1]]\n        person2 <- round_population[selected_people[2]]\n      }\n      #making the new wealth distribution between those two\n      new_wealth <- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] <- new_wealth[1]\n      round_population[selected_people[2]] <- new_wealth[2]\n  }\n  return(round_population)\n}\n\nrepetitions <- 10\n\nfinal_population <- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n```\n:::\n\n\nffndsafjaewklnfdsad I DID IT HELL YES IM SO HAPPY WHAT THE HELL I HAVE BEEN UPDATING THIS CODE NOW PROBS FOR 5 HOURS ONLY AND I GO TIT KFDNHSALFJDJKLÖADSLKNDFSNAKLNKLIHO\n\nDanke Paul dass mer ned uf de Autobahn verunfallt sind (er isch eus heigfahre). Danke Amy fürd unterhaltig vom paul (dass er ned ihschlaft) & das er überlebt (amy het ihm wasser geh). Larissa het gueti Musig gmacht. Und danke Thomas dass er eh paar stunde ned nervig gsi isch.\n\ndown here is my notepad\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(x,y) {\n  # Sum them up\n  pot <- x+y\n  #how to share\n  part1 <- sample(-pot:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n  \n  too_small <- -abs(part1+part2)/2\n  too_big <- part1+part2+(part1+part2)/2\n  too_big}\nrandom_split(100,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 300\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Population.\nMU <- 0 # Mean of the Population\nstd_dev <- 20 # Standard deviation\n\npopulation <- rnorm(N, mean = MU, sd = std_dev)\npopulation[population == 0] <- sample(c(-1, 1), length(population[population == 0]), replace = TRUE)\nround_population <- round(population)\n\nanyone <- function(round_population){\n  sample(seq_along(round_population), 2)\n}\n\nrandom_split <- function(x, y) {\n  pot <- x + y\n  # Ensuring no 0s and reasonable splits\n  part1 <- sample(max(-pot + 1, -100):min(pot - 1, 100), 1)\n  part2 <- pot - part1\n  too_small <- -abs(part1 + part2) / 2\n  too_big <- part1 + part2 + (part1 + part2) / 2\n  \n  while (part1 < too_small || part2 < too_small || (part1 > too_big) || (part2 > too_big)) {\n    part1 <- sample(max(-pot + 1, -100):min(pot - 1, 100), 1)  # Avoiding zero\n    part2 <- pot - part1\n  }\n  \n  return(c(part1, part2))\n}\n\nsimulation <- function(round_population, repetitions) {\n  for (i in 1:repetitions) {\n    selected_people <- anyone(round_population)\n    person1 <- round_population[selected_people[1]]\n    person2 <- round_population[selected_people[2]]\n    \n    # Ensure two different people\n    while (selected_people[1] == selected_people[2]) {\n      selected_people <- anyone(round_population)\n      person1 <- round_population[selected_people[1]]\n      person2 <- round_population[selected_people[2]]\n    }\n    \n    new_wealth <- random_split(person1, person2)\n    \n    # Update the population\n    round_population[selected_people[1]] <- new_wealth[1]\n    round_population[selected_people[2]] <- new_wealth[2]\n  }\n  return(round_population)\n}\n\nrepetitions <- 10\nfinal_population <- simulation(round_population, repetitions)\n\nhist(final_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Population.\nMU <- 0 # Mean of the Population\nstd_dev <- 20 # Standard deviation\n\npopulation <- rnorm(N, mean = MU, sd = std_dev)\npopulation[population == 0] <- sample(c(-1, 1), length(population[population == 0]), replace = TRUE)\nround_population <- round(population)\n\nanyone <- function(round_population){\n  sample(seq_along(round_population), 2)\n}\nanyone(round_population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  671 3704\n```\n\n\n:::\n\n```{.r .cell-code}\nrandom_split <- function(x,y){\n  # Sum them up\n  pot <- x+y\n  if(pot == 0){\n    pot <- x\n  }\n  #how to share\n  part1 <- sample(-pot:pot, 1)\n  #calcutlating the  split \n  part2 <- pot - part1\n  \n  too_small <- -abs(part1 + part2) / 2\n  too_big <- part1 + part2 + (part1+part2) / 2\n  too_big\n\n while (part1 < too_small || part2 < too_small || \n       (part1 == 0 && part2 == 0) || \n       (part1 > too_big) || (part2 > too_big)) {\n  part1 <- sample(-pot:pot, 1)  # Randomly assign part1\n  part2 <- pot - part1 \n  }\n  return(c(part1, part2))\n}\n\nrandom_split(50,-50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 26 24\n```\n\n\n:::\n\n```{.r .cell-code}\nsimulation <- function(x,y) \n  {\n  for (i in 1:y) {\n      selected_people <- anyone(x)\n      #getting the people for trading\n      person1 <- round_population[selected_people[1]]\n      person2 <- round_population[selected_people[2]]\n      #making the new wealth distribution between those two\n      new_wealth <- random_split(person1, person2)\n      #overwriting the old bank statement with the new one\n      round_population[selected_people[1]] <- new_wealth[1]\n      round_population[selected_people[2]] <- new_wealth[2]\n  }\n  return(round_population)\n}\n\nrepetitions <- 10\n\n#final_population <- simulation(round_population, repetitions)\n\n#final_population\n\nhist(round_population, breaks = 50, main = \"After Simulation Grapn\", xlab = \"Value\", col = \"skyblue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}